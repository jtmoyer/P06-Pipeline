function output = f_initial_linelength(data, params, fs, curTime)
  %	Usage: params = f_initial_XXXX(data, params, fs, curTime);
  % Called by f_initialDetection()
  %	
  % f_initial_XXXX calculates a given feature using a sliding window
  % 
  % Input:
  %   params		-	a structure containing settings for the feature (see
  %     f_initialDetection documentation for more detail)
  %   data - block of data to process
  %   fs - sampling frequency of the data, in Hz
  %   curTime - time of the first sample of data block, in microseconds
  %
  % Output:
  %   output  - M x N+1 column matrix.  First column is the time in
  %   microseconds of the right aligned sliding window.  The remaining N
  %   columns are the feature calculated for each channel (N channels).  M
  %   depends on the size of data block and duration/offset of the window.
  %
  % Jason Moyer 7/20/2015 
  % University of Pennsylvania Center for Neuroengineering and Therapeutics
  %
  % History:
  % 7/20/2015 - v1 - creation
  %.............

  %%-----------------------------------------
  %%---  feature creation and data processing
  % calculate number of sliding windows (overlap is ok)
  NumWins = @(xLen, fs, winLen, winDisp) (xLen/fs)/winDisp-(winLen/winDisp-1); 
  nw = int64(NumWins(length(data), fs, params.windowLength, params.windowDisplacement));
  timeOut = zeros(nw,1);
  featureOut = zeros(nw, length(params.channels));

  % filter then normalize each channel by std of entire data block
  origData = data;
  data = high_pass_filter(data, fs);
  data = low_pass_filter(data, fs);
  rmsdata = rms(data,1);
%   rmsdata(rmsdata > params.rmsArtifactThresh) = NaN;
  filtOut = data ./ repmat(rmsdata,size(data,1),1);
%   normalizer = max(std(data)) ./ std(data);
%   for c = 1: length(params.channels)
%     data(:,c) = data(:,c) .* normalizer(c);
%   end

%   % low-pass filter
%   filtOut = low_pass_filter(data, fs); % see below

  % for each window, calculate feature as defined in params
  for w = 1: nw
    winBeg = params.windowDisplacement * fs * (w-1) + 1;
    winEnd = min([winBeg+params.windowLength*fs-1 length(filtOut)]);
    timeOut(w) = winEnd/fs*1e6 + curTime;         % right-aligned
    featureOut(w,:) = params.function(filtOut(winBeg:winEnd,:)); 
  end

  % smooth window using convolution 
  if params.smoothDur > 0
    smoothLength = 1/params.windowDisplacement * params.smoothDur; % in samples of data signal
    smoother =  1 / smoothLength * ones(1,smoothLength);
    for c = 1: length(params.channels)
      featureOut(:,c) = conv(featureOut(:,c),smoother,'same');
    end
  end
  output = [timeOut featureOut];
  %%---  feature creation and data processing
  %%-----------------------------------------
end


function y = low_pass_filter(x,Fs)
  % MATLAB Code
  % Generated by MATLAB(R) 8.2 and the DSP System Toolbox 8.5.
  % Generated on: 09-Mar-2015 11:44:09

  persistent Hd;

  if isempty(Hd)

    N     = 4;     % Order
    F3dB  = 50;    % 3-dB Frequency
    Apass = 1;     % Passband Ripple (dB)

    h = fdesign.lowpass('n,f3db,ap', N, F3dB, Apass, Fs);

    Hd = design(h, 'cheby1', ...
      'SOSScaleNorm', 'Linf');

    set(Hd,'PersistentMemory',true);

  end

  y = filtfilt(Hd.sosMatrix, Hd.ScaleValues, x);
%  y = filter(Hd,x);
end

function y = high_pass_filter(x, Fs)
  % MATLAB Code
  % Generated by MATLAB(R) 8.2 and the DSP System Toolbox 8.5.
  % Generated on: 04-Mar-2015 10:14:48

  persistent Hd;

  if isempty(Hd)

    N     = 3;    % Order
    F3dB  = 4;     % 3-dB Frequency
    Apass = 1;     % Passband Ripple (dB)

    h = fdesign.highpass('n,f3db,ap', N, F3dB, Apass, Fs);

    Hd = design(h, 'cheby1', ...
      'SOSScaleNorm', 'Linf');

    set(Hd,'PersistentMemory',true);

  end
  
  y = filtfilt(Hd.sosMatrix, Hd.ScaleValues, x);
%   y = filtfilt(h,x);
end

